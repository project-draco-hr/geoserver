{
  ScanlineProvider scanlines=ScanlineProviderFactory.getProvider(image);
  ColorModel colorModel=image.getColorModel();
  boolean indexed=colorModel instanceof IndexColorModel;
  boolean hasAlpha=colorModel.hasAlpha();
  int numColorComponents=colorModel.getNumColorComponents();
  boolean grayscale=!indexed && numColorComponents < 3;
  byte bitDepth=scanlines.getBitDepth();
  ImageInfo ii=new ImageInfo(image.getWidth(),image.getHeight(),bitDepth,hasAlpha,grayscale,indexed);
  PngWriter pw=new PngWriter(outStream,ii);
  pw.setShouldCloseStream(false);
  try {
    pw.setCompLevel(4);
    pw.setFilterType(ar.com.hjg.pngj.FilterType.FILTER_NONE);
    if (indexed) {
      IndexColorModel icm=(IndexColorModel)colorModel;
      PngChunkPLTE palette=pw.getMetadata().createPLTEChunk();
      int ncolors=icm.getMapSize();
      palette.setNentries(ncolors);
      for (int i=0; i < ncolors; i++) {
        final int red=icm.getRed(i);
        final int green=icm.getGreen(i);
        final int blue=icm.getBlue(i);
        palette.setEntry(i,red,green,blue);
      }
      if (icm.hasAlpha()) {
        PngChunkTRNS transparent=new PngChunkTRNS(ii);
        int[] alpha=new int[ncolors];
        for (int i=0; i < ncolors; i++) {
          final int a=icm.getAlpha(i);
          alpha[i]=a;
        }
        transparent.setPalletteAlpha(alpha);
        pw.getChunksList().queue(transparent);
      }
    }
    for (int row=0; row < image.getHeight(); row++) {
      pw.writeRow(scanlines);
    }
    pw.end();
  }
 catch (  Exception e) {
    LOGGER.log(Level.SEVERE,"Failed to encode the PNG",e);
    throw new ServiceException(e);
  }
 finally {
    pw.close();
  }
}
