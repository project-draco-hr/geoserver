{
  RenderedImage original=image;
  ScanlineProvider scanlines=ScanlineProviderFactory.getProvider(image);
  if (scanlines == null) {
    image=new ImageWorker(image).rescaleToBytes().forceComponentColorModel().getRenderedImage();
    scanlines=ScanlineProviderFactory.getProvider(image);
  }
  if (scanlines == null) {
    throw new IllegalArgumentException("Could not find a scanline extractor for " + original);
  }
  ColorModel colorModel=image.getColorModel();
  boolean indexed=colorModel instanceof IndexColorModel;
  ImageInfo ii=getImageInfo(image,scanlines,colorModel,indexed);
  PngWriter pw=new PngWriter(outStream,ii);
  pw.setShouldCloseStream(false);
  try {
    pw.setCompLevel(level);
    pw.setFilterType(filterType);
    if (indexed) {
      IndexColorModel icm=(IndexColorModel)colorModel;
      PngChunkPLTE palette=pw.getMetadata().createPLTEChunk();
      int ncolors=icm.getMapSize();
      palette.setNentries(ncolors);
      for (int i=0; i < ncolors; i++) {
        final int red=icm.getRed(i);
        final int green=icm.getGreen(i);
        final int blue=icm.getBlue(i);
        palette.setEntry(i,red,green,blue);
      }
      if (icm.hasAlpha()) {
        PngChunkTRNS transparent=new PngChunkTRNS(ii);
        int[] alpha=new int[ncolors];
        for (int i=0; i < ncolors; i++) {
          final int a=icm.getAlpha(i);
          alpha[i]=a;
        }
        transparent.setPalletteAlpha(alpha);
        pw.getChunksList().queue(transparent);
      }
    }
    for (int row=0; row < image.getHeight(); row++) {
      pw.writeRow(scanlines);
    }
    pw.end();
  }
 catch (  Exception e) {
    LOGGER.log(Level.SEVERE,"Failed to encode the PNG",e);
    throw new ServiceException(e);
  }
 finally {
    pw.close();
  }
  return image;
}
