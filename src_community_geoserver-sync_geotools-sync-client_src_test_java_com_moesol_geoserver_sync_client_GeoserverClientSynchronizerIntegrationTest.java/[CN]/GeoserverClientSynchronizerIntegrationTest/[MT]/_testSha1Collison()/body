{
  FeatureSha1.MAPPER=new FeatureSha1Mapper(){
    @Override public Sha1Value map(    Sha1Value old){
      if ("ba5a86a5a1c34f30e7e3a9e8eef485f025c8d605".equals(old.toString())) {
        return old;
      }
      if ("b0cfdb0661eb1c8b1db7e957915c05f8f2d43aa7".equals(old.toString())) {
        return new Sha1Value("ba5a86a5a1c34f30e7e3a9e8eef485f025c8d605");
      }
      if ("88bfad9cfffeafd299a44d4daf979d57419a2621".equals(old.toString())) {
        return old;
      }
      if ("2a7bc94a06f3221293677515044b0a9dd3960f4e".equals(old.toString())) {
        return new Sha1Value("88bfad9cfffeafd299a44d4daf979d57419a2621");
      }
      throw new IllegalStateException("Mapping of input SHA1's has changed unable to setup test conditions.");
    }
  }
;
  FeatureCollectionType client=make(f("F0",-1),f("F1",0));
  FeatureCollectionType server=make(f("F0",-1));
  GeoserverClientSynchronizer synchronizer=new GeoserverClientSynchronizer(makeConfiguration(),"url",SimulatedRequestBuilder.POST_TEMPLATE){
    @Override protected HashAndFeatureValue makeHashAndFeatureValue(    Feature f){
      HashAndFeatureValue hashFeature=super.makeHashAndFeatureValue(f);
      System.out.println("sha1: " + hashFeature);
      return hashFeature;
    }
  }
;
  RoundListener roundListener=mock(RoundListener.class);
  synchronizer.setRoundListener(roundListener);
  Map<Identifier,FeatureAccessor> clientMap=asMap(client);
  RequestBuilder builder=new SimulatedRequestBuilder(server);
  synchronizer.setRequestBuilder(builder);
  synchronizer.synchronize(clientMap);
  verify(roundListener).sha1Collision();
}
