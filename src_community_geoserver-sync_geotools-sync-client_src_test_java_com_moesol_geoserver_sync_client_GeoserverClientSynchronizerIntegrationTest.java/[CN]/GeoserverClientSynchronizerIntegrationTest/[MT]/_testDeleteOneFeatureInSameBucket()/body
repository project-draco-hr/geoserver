{
  FeatureSha1.MAPPER=new FeatureSha1Mapper(){
    @Override public Sha1Value map(    Sha1Value old){
      if ("e76becbcfbe3b847478a3aa706def57382d8b884".equals(old.toString())) {
        return old;
      }
      if ("ac93e7bcebb89813f206d9b618c94e1531cc6a0d".equals(old.toString())) {
        return new Sha1Value("ba5a86a5a1c34f30e7e3a9e8eef485f025c8d606");
      }
      if ("88bfad9cfffeafd299a44d4daf979d57419a2621".equals(old.toString())) {
        return old;
      }
      if ("2a7bc94a06f3221293677515044b0a9dd3960f4e".equals(old.toString())) {
        return new Sha1Value("88bfad9cfffeafd299a44d4daf979d57419a2622");
      }
      throw new IllegalStateException("Mapping of input SHA1's has changed unable to setup test conditions: " + old);
    }
  }
;
  FeatureCollectionType client=make(f("F0",-1),f("F1",0));
  FeatureCollectionType server;
  GeoserverClientSynchronizer synchronizer=new GeoserverClientSynchronizer(makeConfiguration(),"url",SimulatedRequestBuilder.POST_TEMPLATE){
    @Override protected HashAndFeatureValue makeHashAndFeatureValue(    Feature f){
      HashAndFeatureValue hashFeature=super.makeHashAndFeatureValue(f);
      System.out.println("sha1: " + hashFeature);
      return hashFeature;
    }
  }
;
  Map<Identifier,FeatureAccessor> clientMap=asMap(client);
  server=make(f("F0",-1));
  RequestBuilder builder=new SimulatedRequestBuilder(server);
  synchronizer.setRequestBuilder(builder);
  synchronizer.synchronize(clientMap);
  assertEquals(1,clientMap.size());
  assertEquals(0,synchronizer.getNumCreates());
  assertEquals(0,synchronizer.getNumUpdates());
  assertEquals(1,synchronizer.getNumDeletes());
  assertEquals(21,synchronizer.getNumRounds());
}
