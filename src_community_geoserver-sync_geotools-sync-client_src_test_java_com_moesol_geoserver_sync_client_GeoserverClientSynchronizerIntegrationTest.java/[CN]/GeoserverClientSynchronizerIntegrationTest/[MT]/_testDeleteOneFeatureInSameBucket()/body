{
  FeatureSha1.MAPPER=new FeatureSha1Mapper(){
    @Override public Sha1Value map(    Sha1Value old){
      System.out.println("old " + old);
      if ("88bfad9cfffeafd299a44d4daf979d57419a2621".equals(old.toString())) {
        return old;
      }
      if ("2a7bc94a06f3221293677515044b0a9dd3960f4e".equals(old.toString())) {
        return new Sha1Value("88bfad9cfffeafd299a44d4daf979d57419a2622");
      }
      if ("27f1edbff7fa42bd9160c13ab6b24927393cc0d4".equals(old.toString())) {
        return old;
      }
      if ("48fbf0870bcc58da8e7a49d69295a72dd3c5f4ce".equals(old.toString())) {
        return old;
      }
      throw new IllegalStateException("Mapping of input SHA1's has changed unable to setup test conditions: " + old);
    }
  }
;
  FeatureCollectionType client=make(f("F0",-1),f("F1",0));
  FeatureCollectionType server;
  GeoserverClientSynchronizer synchronizer=new GeoserverClientSynchronizer(makeConfiguration(),"url",SimulatedRequestBuilder.POST_TEMPLATE){
    @Override protected HashAndFeatureValue makeHashAndFeatureValue(    Feature f){
      HashAndFeatureValue hashFeature=super.makeHashAndFeatureValue(f);
      System.out.println("sha1: " + hashFeature);
      return hashFeature;
    }
  }
;
  Map<Identifier,FeatureAccessor> clientMap=asMap(client);
  server=make(f("F0",-1));
  RequestBuilder builder=new SimulatedRequestBuilder(server);
  synchronizer.setRequestBuilder(builder);
  synchronizer.synchronize(clientMap);
  assertEquals(1,clientMap.size());
  assertEquals(0,synchronizer.getNumCreates());
  assertEquals(0,synchronizer.getNumUpdates());
  assertEquals(1,synchronizer.getNumDeletes());
  assertEquals(21,synchronizer.getNumRounds());
}
