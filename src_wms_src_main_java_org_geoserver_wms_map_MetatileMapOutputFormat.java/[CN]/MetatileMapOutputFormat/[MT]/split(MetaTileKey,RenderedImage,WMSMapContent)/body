{
  final int metaFactor=key.getMetaFactor();
  final RenderedImage[] tiles=new RenderedImage[key.getMetaFactor() * key.getMetaFactor()];
  final int tileSize=key.getTileSize();
  int type=0;
  if (metaTile instanceof PlanarImage) {
    type=1;
  }
 else   if (metaTile instanceof BufferedImage) {
    type=2;
  }
  for (int i=0; i < metaFactor; i++) {
    for (int j=0; j < metaFactor; j++) {
      int x=j * tileSize;
      int y=(tileSize * (metaFactor - 1)) - (i * tileSize);
      RenderedImage tile;
switch (type) {
case 0:
        RenderedOp cropped=GTCropDescriptor.create(metaTile,Float.valueOf(x),Float.valueOf(y),Float.valueOf(tileSize),Float.valueOf(tileSize),NO_CACHE_HINTS);
      tile=cropped.getAsBufferedImage();
    break;
case 1:
  final PlanarImage pImage=(PlanarImage)metaTile;
final WritableRaster wTile=WritableRaster.createWritableRaster(pImage.getSampleModel().createCompatibleSampleModel(tileSize,tileSize),new Point(x,y));
Rectangle sourceArea=new Rectangle(x,y,tileSize,tileSize);
sourceArea=sourceArea.intersection(pImage.getBounds());
pImage.copyData(wTile);
if (wTile.getMinX() != 0 || wTile.getMinY() != 0) {
tile=new BufferedImage(pImage.getColorModel(),(WritableRaster)wTile.createTranslatedChild(0,0),pImage.getColorModel().isAlphaPremultiplied(),null);
}
 else {
tile=new BufferedImage(pImage.getColorModel(),wTile,pImage.getColorModel().isAlphaPremultiplied(),null);
}
break;
case 2:
final BufferedImage image=(BufferedImage)metaTile;
tile=image.getSubimage(x,y,tileSize,tileSize);
break;
default :
throw new IllegalStateException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2,"metaTile class",metaTile.getClass().toString()));
}
tiles[(i * key.getMetaFactor()) + j]=tile;
}
}
if (type < 2) {
ImageUtilities.disposePlanarImageChain((PlanarImage)metaTile);
}
 else {
BufferedImage image=(BufferedImage)metaTile;
image.flush();
image=null;
}
return tiles;
}
