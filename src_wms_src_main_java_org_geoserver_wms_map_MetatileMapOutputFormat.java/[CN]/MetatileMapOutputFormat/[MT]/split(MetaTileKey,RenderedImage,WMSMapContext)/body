{
  final int metaFactor=key.getMetaFactor();
  final RenderedImage[] tiles=new RenderedImage[key.getMetaFactor() * key.getMetaFactor()];
  final int tileSize=key.getTileSize();
  final RenderingHints no_cache=new RenderingHints(JAI.KEY_TILE_CACHE,null);
  final int tileW=metaTile.getTileWidth();
  final int tileH=metaTile.getTileHeight();
  final int tileGridXOffset=metaTile.getTileGridXOffset();
  final int tileGridYOffset=metaTile.getTileGridYOffset();
  final boolean metatilingIsRespected=tileGridXOffset == 0 && tileGridYOffset == 0 && tileH == tileSize && tileW == tileSize;
  for (int i=0; i < metaFactor; i++) {
    for (int j=0; j < metaFactor; j++) {
      int x=j * tileSize;
      int y=(tileSize * (metaFactor - 1)) - (i * tileSize);
      final Raster tile_;
      RenderedImage tile;
      if (metaTile instanceof PlanarImage) {
        final PlanarImage pImage=(PlanarImage)metaTile;
        if (metatilingIsRespected) {
          final int tileX=pImage.XToTileX(x);
          final int tileY=pImage.YToTileY(y);
          tile_=pImage.getTile(tileX,tileY);
        }
 else {
          Rectangle sourceArea=new Rectangle(x,y,tileSize,tileSize);
          sourceArea=sourceArea.intersection(pImage.getBounds());
          tile_=pImage.getData(sourceArea);
        }
        WritableRaster wTile=WritableRaster.createWritableRaster(tile_.getSampleModel().createCompatibleSampleModel(tileSize,tileSize),tile_.getDataBuffer(),new Point(0,0));
        tile=new BufferedImage(pImage.getColorModel(),wTile,pImage.getColorModel().isAlphaPremultiplied(),null);
      }
 else       if (metaTile instanceof BufferedImage) {
        final BufferedImage image=(BufferedImage)metaTile;
        tile=image.getSubimage(x,y,tileSize,tileSize);
      }
 else {
        tile=CropDescriptor.create(metaTile,new Float(x),new Float(y),new Float(tileSize),new Float(tileSize),no_cache);
      }
      tiles[(i * key.getMetaFactor()) + j]=tile;
    }
  }
  return tiles;
}
