{
  CatalogStoreMapping mapping=getMapping(q.getTypeName());
  int startIndex=0;
  if (q.getStartIndex() != null) {
    startIndex=q.getStartIndex();
  }
  CSWUnmappingFilterVisitor unmapper=new CSWUnmappingFilterVisitor(mapping,rd);
  Filter unmapped=Filter.INCLUDE;
  if (q.getFilter() != null && q.getFilter() != Filter.INCLUDE) {
    Filter filter=q.getFilter();
    unmapped=(Filter)filter.accept(unmapper,null);
  }
  if (q.getProperties() != null && q.getProperties().size() > 0) {
    mapping=mapping.subMapping(q.getProperties(),rd);
  }
  SortBy[] unmappedSortBy=null;
  if (q.getSortBy() != null && q.getSortBy().length > 0) {
    unmappedSortBy=new SortBy[q.getSortBy().length];
    for (int i=0; i < q.getSortBy().length; i++) {
      SortBy sortby=q.getSortBy()[i];
      Expression expr=(Expression)sortby.getPropertyName().accept(unmapper,null);
      if (!(expr instanceof PropertyName)) {
        throw new IOException("Sorting on " + sortby.getPropertyName() + " is not supported.");
      }
      unmappedSortBy[i]=new SortByImpl((PropertyName)expr,sortby.getSortOrder());
    }
  }
  return new CatalogStoreFeatureCollection(startIndex,q.getMaxFeatures(),unmappedSortBy,unmapped,catalog,mapping,rd);
}
