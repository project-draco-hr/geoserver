{
  GeoPackage geopkg=new GeoPackage();
  geopkg.init();
  GetMapRequest req=map.getRequest();
  List<Layer> layers=map.layers();
  List<MapLayerInfo> mapLayers=req.getLayers();
  Preconditions.checkState(layers.size() == mapLayers.size(),"Number of map layers not same as number of rendered layers");
  List<MapLayerInfo> tileLayers=new ArrayList();
  Map formatOpts=req.getFormatOptions();
  Mode mode=formatOpts.containsKey("mode") ? Mode.valueOf(((String)formatOpts.get("mode")).toUpperCase()) : Mode.VECTOR;
  if (mode == Mode.TILED) {
    tileLayers.addAll(mapLayers);
  }
 else {
    for (int i=0; i < layers.size(); i++) {
      Layer layer=layers.get(i);
      MapLayerInfo mapLayer=mapLayers.get(i);
      if (layer instanceof FeatureLayer) {
        addFeatureLayer(geopkg,(FeatureLayer)layer,mapLayer,map);
      }
 else       if (layer instanceof GridCoverageLayer) {
        if (mode == Mode.HYBRID) {
          addCoverageLayer(geopkg,(GridCoverageLayer)layer,mapLayer,map);
        }
 else {
          tileLayers.add(mapLayer);
        }
      }
 else {
        tileLayers.add(mapLayer);
      }
    }
  }
  addTileLayers(geopkg,tileLayers,map);
  geopkg.close();
  final File dbFile=geopkg.getFile();
  final BufferedInputStream bin=new BufferedInputStream(new FileInputStream(dbFile));
  RawMap result=new RawMap(map,bin,MIME_TYPE){
    @Override public void writeTo(    OutputStream out) throws IOException {
      String dbFilename=getAttachmentFileName();
      if (dbFilename != null) {
        dbFilename=dbFilename.substring(0,dbFilename.length() - 4) + ".gpkg";
      }
 else {
        dbFilename="geoserver.gpkg";
      }
      IOUtils.copy(bin,out);
      out.flush();
      bin.close();
      try {
        dbFile.delete();
      }
 catch (      Exception e) {
        LOGGER.log(Level.WARNING,"Error deleting file: " + dbFile.getAbsolutePath(),e);
      }
    }
  }
;
  result.setContentDispositionHeader(map,".gpkg",true);
  return result;
}
