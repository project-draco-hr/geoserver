{
  WCSInfo wcs=getServiceInfo();
  CoverageInfo meta=null;
  GridCoverage2D coverage=null;
  final List<GridCoverage> coverageResults=new ArrayList<GridCoverage>();
  try {
    meta=catalog.getCoverageByName(request.getSourceCoverage());
    if (meta == null)     throw new WcsException("Cannot find sourceCoverage on the catalog!");
    checkRangeSubset(meta,request.getRangeSubset());
    checkInterpolationMethod(meta,request.getInterpolationMethod());
    checkOutput(meta,request.getOutput());
    final DomainSubsetType domainSubset=request.getDomainSubset();
    final TimeSequenceType temporalSubset=domainSubset.getTemporalSubset();
    final SpatialSubsetType spatialSubset=domainSubset.getSpatialSubset();
    final EList grids=spatialSubset.getGrid();
    if (grids.size() == 0)     throw new IllegalArgumentException("Invalid number of Grid for spatial subsetting was set:" + grids.size());
    final RectifiedGridType grid=(RectifiedGridType)grids.get(0);
    final List envelopes=spatialSubset.getEnvelope();
    if (envelopes.size() == 0)     throw new IllegalArgumentException("Invalid number of Envelope for spatial subsetting was set:" + envelopes.size());
    final GeneralEnvelope requestedEnvelope=(GeneralEnvelope)envelopes.get(0);
    final OutputType output=request.getOutput();
    if (output == null)     throw new IllegalArgumentException("Output type was null");
    final CodeType outputCRS=output.getCrs();
    final int dimension=grid.getDimension().intValue();
    if (dimension == 3)     throw new WcsException("We support a third dimension only via a specifica Axis in Range",InvalidParameterValue,null);
    final AbstractGridCoverage2DReader reader=(AbstractGridCoverage2DReader)meta.getGridCoverageReader(null,WCSUtils.getReaderHints(wcs));
    if (reader == null) {
      return coverageResults.toArray(new GridCoverage2D[]{});
    }
    final GeneralEnvelope nativeEnvelope=reader.getOriginalEnvelope();
    final CoordinateReferenceSystem nativeCRS=nativeEnvelope.getCoordinateReferenceSystem();
    String requestedCRS=null;
    if (outputCRS != null) {
      requestedCRS=outputCRS.getValue();
    }
    final CoordinateReferenceSystem targetCRS;
    if (requestedCRS == null) {
      targetCRS=reader.getOriginalEnvelope().getCoordinateReferenceSystem();
      requestedCRS=CRS.lookupIdentifier(targetCRS,true);
    }
 else {
      targetCRS=CRS.decode(requestedCRS,true);
    }
    final Rectangle destinationSize;
    final AffineTransform2D destinationG2W;
    final GridEnvelope limits=grid.getLimits();
    if (limits != null) {
      final int[] lowers=limits.getLow().getCoordinateValues();
      destinationG2W=null;
      destinationSize=new Rectangle(lowers[0],lowers[1],limits.getSpan(0),limits.getSpan(1));
    }
 else     if (grid.getOffsetVector() != null && grid.getOffsetVector().size() > 0) {
      final VectorType offsetVector=(VectorType)grid.getOffsetVector().get(0);
      final List offsetValues=offsetVector.getValue();
      final double resX=(Double)offsetValues.get(0);
      final double resY=(Double)offsetValues.get(1);
      final DirectPositionType origin_=grid.getOrigin().getPos();
      destinationSize=null;
      destinationG2W=new AffineTransform2D(resX,0d,0d,resY,(Double)origin_.getValue().get(0),(Double)origin_.getValue().get(1));
    }
 else     throw new WcsException("Invalid Grid value:" + grid.toString(),InvalidParameterValue,null);
    double[] elevations=null;
    List axisSubset=null;
    if (request.getRangeSubset() != null) {
      axisSubset=request.getRangeSubset().getAxisSubset();
      if (axisSubset.size() > 0) {
        for (int a=0; a < axisSubset.size(); a++) {
          AxisSubsetType axis=(AxisSubsetType)axisSubset.get(a);
          String axisName=axis.getName();
          if (axisName.equalsIgnoreCase(WCSUtils.ELEVATION)) {
            if (axis.getSingleValue().size() > 0) {
              elevations=new double[axis.getSingleValue().size()];
              for (int s=0; s < axis.getSingleValue().size(); s++) {
                elevations[s]=Double.parseDouble(((TypedLiteralType)axis.getSingleValue().get(s)).getValue());
              }
            }
 else             if (axis.getInterval().size() > 0) {
              IntervalType interval=(IntervalType)axis.getInterval().get(0);
              int min=Integer.parseInt(interval.getMin().getValue());
              int max=Integer.parseInt(interval.getMax().getValue());
              int res=(interval.getRes() != null ? Integer.parseInt(interval.getRes().getValue()) : 1);
              elevations=new double[(int)(Math.floor(max - min) / res + 1)];
              for (int b=0; b < elevations.length; b++)               elevations[b]=(min + b * res);
            }
          }
        }
      }
    }
    final List<Date> timeValues=new LinkedList<Date>();
    if (temporalSubset != null && temporalSubset.getTimePosition() != null && temporalSubset.getTimePosition().size() > 0) {
      final EList timePositionLists=temporalSubset.getTimePosition();
      for (Iterator it=timePositionLists.iterator(); it.hasNext(); ) {
        TimePositionTypeImpl tp=(TimePositionTypeImpl)it.next();
        timeValues.add((Date)tp.getValue());
      }
    }
    final ParameterValueGroup readParametersDescriptor=reader.getFormat().getReadParameters();
    GeneralParameterValue[] readParameters=CoverageUtils.getParameters(readParametersDescriptor,meta.getParameters());
    readParameters=(readParameters != null ? readParameters : new GeneralParameterValue[0]);
    final GridGeometry2D requestedGridGeometry;
    if (destinationSize != null)     requestedGridGeometry=new GridGeometry2D(new GridEnvelope2D(destinationSize),getHorizontalEnvelope(requestedEnvelope));
 else     requestedGridGeometry=new GridGeometry2D(PixelInCell.CELL_CENTER,destinationG2W,getHorizontalEnvelope(requestedEnvelope),null);
    final ParameterValue<GeneralGridGeometry> requestedGridGeometryParam=new DefaultParameterDescriptor<GeneralGridGeometry>(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName().toString(),GeneralGridGeometry.class,null,requestedGridGeometry).createValue();
    final List<GeneralParameterDescriptor> parameterDescriptors=readParametersDescriptor.getDescriptor().descriptors();
    ParameterValue time=null;
    boolean hasTime=timeValues.size() > 0;
    ParameterValue elevation=null;
    boolean hasElevation=elevations != null && !Double.isNaN(elevations[0]);
    if (hasElevation || hasTime) {
      for (      GeneralParameterDescriptor pd : parameterDescriptors) {
        final String code=pd.getName().getCode();
        if (code.equalsIgnoreCase("TIME")) {
          time=(ParameterValue)pd.createValue();
          time.setValue(timeValues);
        }
        if (code.equalsIgnoreCase(WCSUtils.ELEVATION)) {
          elevation=(ParameterValue)pd.createValue();
          elevation.setValue(elevations[0]);
        }
        if ((hasElevation && elevation != null && hasTime && time != null) || !hasElevation && hasTime && time != null || hasElevation && elevation != null && !hasTime)         break;
      }
    }
    int addedParams=1 + (hasTime ? 1 : 0) + (hasElevation ? 1 : 0);
    GeneralParameterValue[] readParametersClone=new GeneralParameterValue[readParameters.length + addedParams--];
    System.arraycopy(readParameters,0,readParametersClone,0,readParameters.length);
    readParametersClone[readParameters.length + addedParams--]=requestedGridGeometryParam;
    if (hasTime)     readParametersClone[readParameters.length + addedParams--]=time;
    if (hasElevation)     readParametersClone[readParameters.length + addedParams--]=elevation;
    readParameters=readParametersClone;
    WCSUtils.checkInputLimits(wcs,meta,reader,requestedGridGeometry);
    coverage=(GridCoverage2D)reader.read(readParameters);
    if ((coverage == null) || !(coverage instanceof GridCoverage2D)) {
      throw new IOException("The requested coverage could not be found.");
    }
    WCSUtils.checkInputLimits(wcs,coverage);
    GridCoverage2D bandSelectedCoverage=coverage;
    String interpolationType=null;
    if (request.getRangeSubset() != null) {
      interpolationType=request.getInterpolationMethod().getLiteral();
      axisSubset=request.getRangeSubset().getAxisSubset();
      if (axisSubset.size() > 0) {
        for (int a=0; a < axisSubset.size(); a++) {
          AxisSubsetType axis=(AxisSubsetType)axisSubset.get(a);
          try {
            String axisName=axis.getName();
            if (axisName.equalsIgnoreCase("Band")) {
              int[] bands=null;
              if (axis.getSingleValue().size() > 0) {
                bands=new int[axis.getSingleValue().size()];
                for (int s=0; s < axis.getSingleValue().size(); s++) {
                  bands[s]=Integer.parseInt(((TypedLiteralType)axis.getSingleValue().get(s)).getValue()) - 1;
                }
              }
 else               if (axis.getInterval().size() > 0) {
                IntervalType interval=(IntervalType)axis.getInterval().get(0);
                int min=Integer.parseInt(interval.getMin().getValue());
                int max=Integer.parseInt(interval.getMax().getValue());
                int res=(interval.getRes() != null ? Integer.parseInt(interval.getRes().getValue()) : 1);
                bands=new int[(int)(Math.floor(max - min) / res + 1)];
                for (int b=0; b < bands.length; b++)                 bands[b]=(min + b * res) - 1;
              }
              bandSelectedCoverage=(GridCoverage2D)WCSUtils.bandSelect(coverage,bands);
            }
          }
 catch (          Exception e) {
            throw new WcsException("Band Select Operation: " + e.getLocalizedMessage());
          }
        }
      }
    }
    Interpolation interpolation=Interpolation.getInstance(Interpolation.INTERP_NEAREST);
    if (interpolationType != null) {
      if (interpolationType.equalsIgnoreCase("bilinear")) {
        interpolation=Interpolation.getInstance(Interpolation.INTERP_BILINEAR);
      }
 else       if (interpolationType.equalsIgnoreCase("bicubic")) {
        interpolation=Interpolation.getInstance(Interpolation.INTERP_BICUBIC);
      }
 else       if (interpolationType.equalsIgnoreCase("nearest neighbor")) {
        interpolation=Interpolation.getInstance(Interpolation.INTERP_NEAREST);
      }
    }
    GeneralEnvelope destinationEnvelope=(GeneralEnvelope)getHorizontalEnvelope(computeIntersectionEnvelope(requestedEnvelope,nativeEnvelope));
    if (targetCRS != null) {
      MathTransform mt=CRS.findMathTransform(nativeCRS,targetCRS);
      destinationEnvelope=CRS.transform(mt,destinationEnvelope);
      destinationEnvelope.setCoordinateReferenceSystem(targetCRS);
    }
    final GridGeometry2D destinationGridGeometry;
    if (destinationSize != null) {
      destinationGridGeometry=new GridGeometry2D(new GridEnvelope2D(destinationSize),destinationEnvelope);
    }
 else {
      destinationGridGeometry=new GridGeometry2D(PixelInCell.CELL_CENTER,destinationG2W,destinationEnvelope,null);
    }
    WCSUtils.checkOutputLimits(wcs,destinationGridGeometry.getGridRange2D(),bandSelectedCoverage.getRenderedImage().getSampleModel());
    final GridCoverage2D finalCoverage=WCSUtils.resample(bandSelectedCoverage,nativeCRS,targetCRS,destinationGridGeometry,interpolation);
    coverageResults.add(finalCoverage);
    return coverageResults.toArray(new GridCoverage2D[]{});
  }
 catch (  Exception e) {
    if (e instanceof WcsException)     throw (WcsException)e;
 else     throw new WcsException(e);
  }
}
