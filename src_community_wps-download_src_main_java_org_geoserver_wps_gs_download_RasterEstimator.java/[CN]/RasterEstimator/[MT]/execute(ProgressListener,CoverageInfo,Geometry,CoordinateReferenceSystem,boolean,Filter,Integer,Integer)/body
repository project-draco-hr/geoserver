{
  final long rasterSizeLimits=downloadServiceConfiguration.getRasterSizeLimits();
  if (rasterSizeLimits <= 0) {
    if (LOGGER.isLoggable(Level.FINE)) {
      LOGGER.fine("No raster size limits, moving on....");
    }
    return true;
  }
  if (LOGGER.isLoggable(Level.FINE)) {
    LOGGER.fine("Raster size limits: " + rasterSizeLimits);
  }
  if (LOGGER.isLoggable(Level.FINE)) {
    LOGGER.fine("Checking download limits for raster request");
  }
  CoordinateReferenceSystem nativeCRS=DownloadUtilities.getNativeCRS(coverageInfo);
  if (LOGGER.isLoggable(Level.FINE)) {
    LOGGER.fine("Native CRS is " + nativeCRS.toWKT());
  }
  ROIManager roiManager=null;
  if (roi != null) {
    if (LOGGER.isLoggable(Level.FINE)) {
      LOGGER.log(Level.FINE,"Pushing ROI to native CRS");
    }
    CoordinateReferenceSystem roiCRS=(CoordinateReferenceSystem)roi.getUserData();
    roiManager=new ROIManager(roi,roiCRS);
    roiManager.useNativeCRS(nativeCRS);
  }
  final GridCoverage2DReader reader=(GridCoverage2DReader)coverageInfo.getGridCoverageReader(null,null);
  final long areaRead;
  ScaleToTarget scaling=null;
  if (roi != null) {
    if (LOGGER.isLoggable(Level.FINE)) {
      LOGGER.log(Level.FINE,"Reprojecting ROI");
    }
    final Geometry safeRoiInNativeCRS=roiManager.getSafeRoiInNativeCRS();
    Geometry roiInNativeCRS_=safeRoiInNativeCRS.intersection(FeatureUtilities.getPolygon(reader.getOriginalEnvelope(),new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING))));
    if (roiInNativeCRS_.isEmpty()) {
      if (LOGGER.isLoggable(Level.FINE)) {
        LOGGER.log(Level.FINE,"Empty intersection, so the result does not exceed the limits");
      }
      return true;
    }
    ReferencedEnvelope refEnvelope=JTS.toEnvelope(roiInNativeCRS_.getEnvelope());
    scaling=new ScaleToTarget(reader,refEnvelope);
  }
 else {
    scaling=new ScaleToTarget(reader);
  }
  scaling.setTargetSize(targetSizeX,targetSizeY);
  GridGeometry2D gg=scaling.getGridGeometry();
  areaRead=(long)gg.getGridRange2D().width * gg.getGridRange2D().height;
  if (LOGGER.isLoggable(Level.FINE)) {
    LOGGER.fine("Area to read in pixels: " + areaRead);
  }
  long targetArea=1L;
  Integer[] targetSize=scaling.getTargetSize();
  if (targetSize[0] != null && targetSize[1] != null) {
    targetArea=(long)targetSize[0] * targetSize[1];
  }
  if (areaRead >= Integer.MAX_VALUE || targetArea >= Integer.MAX_VALUE) {
    if (LOGGER.isLoggable(Level.FINE)) {
      LOGGER.log(Level.FINE,"Area to read or target image size exceed maximum integer value: " + Integer.MAX_VALUE);
    }
    return false;
  }
  if (areaRead > rasterSizeLimits) {
    if (LOGGER.isLoggable(Level.FINE)) {
      LOGGER.log(Level.FINE,"Area exceeds the limits");
    }
    return false;
  }
  if (LOGGER.isLoggable(Level.FINE)) {
    LOGGER.log(Level.FINE,"Area does not exceeds the limits");
  }
  return true;
}
