{
  DatatypeConverterImpl xmlTimeConverter=DatatypeConverterImpl.getInstance();
  DateRange range=null;
  for (  DimensionSubsetType dim : request.getDimensionSubset()) {
    String dimension=getDimensionName(dim);
    if (!TIME_NAMES.contains(dimension.toLowerCase())) {
      continue;
    }
    if (range != null) {
      throw new WCS20Exception("Time dimension trimming/slicing specified twice in the request",WCS20Exception.WCS20ExceptionCode.InvalidSubsetting,"subset");
    }
    if (dim instanceof DimensionTrimType) {
      final DimensionTrimType trim=(DimensionTrimType)dim;
      final Date low=xmlTimeConverter.parseDateTime(trim.getTrimLow()).getTime();
      final Date high=xmlTimeConverter.parseDateTime(trim.getTrimHigh()).getTime();
      if (low.compareTo(high) > 0) {
        throw new WCS20Exception("Low greater than High: " + trim.getTrimLow() + ", "+ trim.getTrimHigh(),WCS20Exception.WCS20ExceptionCode.InvalidSubsetting,"subset");
      }
      range=new DateRange(low,high);
    }
 else     if (dim instanceof DimensionSliceType) {
      final DimensionSliceType slicing=(DimensionSliceType)dim;
      final String slicePointS=slicing.getSlicePoint();
      final Date slicePoint=xmlTimeConverter.parseDateTime(slicePointS).getTime();
      range=new DateRange(slicePoint,slicePoint);
    }
 else {
      throw new WCS20Exception("Invalid element found while attempting to parse dimension subsetting request: " + dim.getClass().toString(),WCS20Exception.WCS20ExceptionCode.InvalidSubsetting,"subset");
    }
  }
  if (!range.getMinValue().equals(range.getMaxValue())) {
    throw new WCS20Exception("Trimming on time is not supported at the moment, only slicing is");
  }
  if (range != null) {
    ReaderDimensionsAccessor accessor=new ReaderDimensionsAccessor(reader);
    TreeSet<Object> domain=accessor.getTimeDomain();
    Date slicePoint=range.getMinValue();
    if (!domainContains(slicePoint,domain)) {
      Date previous=null;
      Date newSlicePoint=null;
      TreeSet<Date> domainDates=getDomainDates(domain);
      for (      Date curr : domainDates) {
        if (curr.compareTo(slicePoint) > 0) {
          if (previous == null) {
            newSlicePoint=curr;
            break;
          }
 else {
            long diffPrevious=slicePoint.getTime() - previous.getTime();
            long diffCurr=curr.getTime() - slicePoint.getTime();
            if (diffCurr > diffPrevious) {
              newSlicePoint=curr;
              break;
            }
 else {
              newSlicePoint=previous;
              break;
            }
          }
        }
 else {
          previous=curr;
        }
      }
      if (newSlicePoint == null) {
        newSlicePoint=previous;
      }
      range=new DateRange(newSlicePoint,newSlicePoint);
    }
  }
  return range;
}
