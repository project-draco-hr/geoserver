{
  final SimplifyingFilterVisitor filterSimplifier=new SimplifyingFilterVisitor();
  this.predicateBuilder=new FilterToCatalogSQL(this.queryType,this.dbMappings);
{
    Capabilities fcs=new Capabilities(FilterToCatalogSQL.CAPABILITIES);
    FeatureType parent=null;
    ClientTransactionAccessor transactionAccessor=new ClientTransactionAccessor(){
      @Override public Filter getUpdateFilter(      final String attributePath){
        Set<PropertyType> propertyTypes;
        propertyTypes=dbMappings.getPropertyTypes(queryType,attributePath);
        final boolean isMappedProp=!propertyTypes.isEmpty();
        if (isMappedProp) {
          return null;
        }
        return Filter.EXCLUDE;
      }
      @Override public Filter getDeleteFilter(){
        return null;
      }
    }
;
    CapabilitiesFilterSplitter filterSplitter;
    filterSplitter=new CapabilitiesFilterSplitter(fcs,parent,transactionAccessor);
    final Filter filter=(Filter)this.originalFilter.accept(filterSimplifier,null);
    filter.accept(filterSplitter,null);
    Filter supported=filterSplitter.getFilterPre();
    Filter unsupported=filterSplitter.getFilterPost();
    this.supportedFilter=(Filter)supported.accept(filterSimplifier,null);
    this.unsupportedFilter=(Filter)unsupported.accept(filterSimplifier,null);
  }
  StringBuilder whereClause=new StringBuilder();
  whereClause=(StringBuilder)this.supportedFilter.accept(predicateBuilder,whereClause);
  StringBuilder query=new StringBuilder();
  if (isCountQuery) {
    if (Filter.INCLUDE.equals(this.originalFilter)) {
      query.append("select count(oid) from object where type_id in (:types)");
    }
 else {
      query.append("select count(oid) from object where type_id in (:types) AND (\n");
      query.append(whereClause).append("\n)");
    }
  }
 else {
    final SortBy order=this.sortOrder;
    if (order == null) {
      query.append("select id from object where type_id in (:types) AND (\n");
      query.append(whereClause).append(")\n");
      query.append(" ORDER BY oid");
    }
 else {
      final String sortProperty=order.getPropertyName().getPropertyName();
      final Set<Integer> sortPropertyTypeIds;
      sortPropertyTypeIds=dbMappings.getPropertyTypeIds(queryType,sortProperty);
      Map<String,Object> namedParameters=getNamedParameters();
      namedParameters.put("sortProperty",sortPropertyTypeIds);
      query.append("select id from object_property where property_type in (:sortProperty) AND (\n");
      query.append(whereClause).append("\n)\n");
      query.append(" ORDER BY value ").append(SortOrder.ASCENDING.equals(order.getSortOrder()) ? "ASC" : "DESC");
    }
    applyOffsetLimit(query);
  }
  return query;
}
