{
  final MapDecorationLayout layout=findDecorationLayout(mapContent,tiled);
  Rectangle paintArea=new Rectangle(0,0,mapContent.getMapWidth(),mapContent.getMapHeight());
  if (LOGGER.isLoggable(Level.FINE)) {
    LOGGER.fine("setting up " + paintArea.width + "x"+ paintArea.height+ " image");
  }
  final GetMapRequest request=mapContent.getRequest();
  String antialias=(String)request.getFormatOptions().get("antialias");
  if (antialias != null)   antialias=antialias.toUpperCase();
  IndexColorModel palette=null;
  final boolean transparent=mapContent.isTransparent() && isTransparencySupported();
  final Color bgColor=mapContent.getBgColor();
  if (AA_NONE.equals(antialias)) {
    palette=mapContent.getPalette();
  }
 else   if (AA_NONE.equals(antialias)) {
    PaletteExtractor pe=new PaletteExtractor(transparent ? null : bgColor);
    List<Layer> layers=mapContent.layers();
    for (int i=0; i < layers.size(); i++) {
      pe.visit(layers.get(i).getStyle());
      if (!pe.canComputePalette())       break;
    }
    if (pe.canComputePalette())     palette=pe.getPalette();
  }
  long maxMemory=wms.getMaxRequestMemory() * KB;
  long memory=getDrawingSurfaceMemoryUse(paintArea.width,paintArea.height,palette,transparent);
  StreamingRenderer testRenderer=new StreamingRenderer();
  testRenderer.setMapContent(mapContent);
  memory+=testRenderer.getMaxBackBufferMemory(paintArea.width,paintArea.height);
  if (maxMemory > 0 && memory > maxMemory) {
    long kbUsed=memory / KB;
    long kbMax=maxMemory / KB;
    throw new ServiceException("Rendering request would use " + kbUsed + "KB, whilst the "+ "maximum memory allowed is "+ kbMax+ "KB");
  }
  RenderedImage image=null;
  if (DefaultWebMapService.isDirectRasterPathEnabled() && mapContent.layers().size() == 1 && mapContent.getAngle() == 0.0 && (layout == null || layout.isEmpty())) {
    List<GridCoverage2D> renderedCoverages=new ArrayList<GridCoverage2D>(2);
    try {
      image=directRasterRender(mapContent,0,renderedCoverages);
    }
 catch (    Exception e) {
      throw new ServiceException("Error rendering coverage on the fast path",e);
    }
    if (image != null) {
      return buildMap(mapContent,image);
    }
  }
  boolean useAlpha=transparent || MetatileMapOutputFormat.isRequestTiled(request,this);
  final RenderedImage preparedImage=prepareImage(paintArea.width,paintArea.height,palette,useAlpha);
  final Map<RenderingHints.Key,Object> hintsMap=new HashMap<RenderingHints.Key,Object>();
  final Graphics2D graphic=ImageUtils.prepareTransparency(transparent,bgColor,preparedImage,hintsMap);
  if (AA_NONE.equals(antialias)) {
    hintsMap.put(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
    if (preparedImage.getColorModel() instanceof IndexColorModel) {
      hintsMap.put(RenderingHints.KEY_DITHERING,RenderingHints.VALUE_DITHER_DISABLE);
    }
  }
 else   if (AA_TEXT.equals(antialias)) {
    hintsMap.put(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
    hintsMap.put(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
  }
 else {
    if (antialias != null && !AA_FULL.equals(antialias)) {
      LOGGER.warning("Unrecognized antialias setting '" + antialias + "', valid values are "+ AA_SETTINGS);
    }
    hintsMap.put(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  }
  hintsMap.put(RenderingHints.KEY_FRACTIONALMETRICS,RenderingHints.VALUE_FRACTIONALMETRICS_ON);
  hintsMap.put(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  if (wms != null) {
    if (WMSInterpolation.Nearest.equals(wms.getInterpolation())) {
      hintsMap.put(JAI.KEY_INTERPOLATION,NN_INTERPOLATION);
      hintsMap.put(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
    }
 else     if (WMSInterpolation.Bilinear.equals(wms.getInterpolation())) {
      hintsMap.put(JAI.KEY_INTERPOLATION,BIL_INTERPOLATION);
      hintsMap.put(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
    }
 else     if (WMSInterpolation.Bicubic.equals(wms.getInterpolation())) {
      hintsMap.put(JAI.KEY_INTERPOLATION,BIC_INTERPOLATION);
      hintsMap.put(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    }
  }
  graphic.setRenderingHints(hintsMap);
  RenderingHints hints=new RenderingHints(hintsMap);
  GTRenderer renderer;
  if (DefaultWebMapService.useShapefileRenderer()) {
    renderer=new ShapefileRenderer();
  }
 else {
    StreamingRenderer sr=new StreamingRenderer();
    sr.setThreadPool(DefaultWebMapService.getRenderingPool());
    renderer=sr;
  }
  renderer.setMapContent(mapContent);
  renderer.setJava2DHints(hints);
  Map<Object,Object> rendererParams=new HashMap<Object,Object>();
  rendererParams.put("optimizedDataLoadingEnabled",new Boolean(true));
  rendererParams.put("renderingBuffer",new Integer(mapContent.getBuffer()));
  rendererParams.put("maxFiltersToSendToDatastore",DefaultWebMapService.getMaxFilterRules());
  rendererParams.put(ShapefileRenderer.SCALE_COMPUTATION_METHOD_KEY,ShapefileRenderer.SCALE_OGC);
  if (AA_NONE.equals(antialias)) {
    rendererParams.put(ShapefileRenderer.TEXT_RENDERING_KEY,StreamingRenderer.TEXT_RENDERING_STRING);
  }
 else {
    rendererParams.put(ShapefileRenderer.TEXT_RENDERING_KEY,StreamingRenderer.TEXT_RENDERING_ADAPTIVE);
  }
  if (DefaultWebMapService.isLineWidthOptimizationEnabled()) {
    rendererParams.put(StreamingRenderer.LINE_WIDTH_OPTIMIZATION_KEY,true);
  }
  rendererParams.put(StreamingRenderer.ADVANCED_PROJECTION_HANDLING_KEY,true);
  if (DefaultWebMapService.isContinuousMapWrappingEnabled()) {
    rendererParams.put(StreamingRenderer.CONTINUOUS_MAP_WRAPPING,true);
  }
  if (mapContent.getRequest().getFormatOptions().get("dpi") != null) {
    rendererParams.put(StreamingRenderer.DPI_KEY,((Integer)mapContent.getRequest().getFormatOptions().get("dpi")));
  }
  boolean kmplacemark=false;
  if (mapContent.getRequest().getFormatOptions().get("kmplacemark") != null)   kmplacemark=((Boolean)mapContent.getRequest().getFormatOptions().get("kmplacemark")).booleanValue();
  if (kmplacemark) {
    KMLStyleFilteringVisitor dupVisitor=new KMLStyleFilteringVisitor();
    List<Layer> layers=mapContent.layers();
    for (int i=0; i < layers.size(); i++) {
      if (layers.get(i) instanceof StyleLayer) {
        StyleLayer layer=(StyleLayer)layers.get(i);
        Style style=layer.getStyle();
        style.accept(dupVisitor);
        Style copy=(Style)dupVisitor.getCopy();
        layer.setStyle(copy);
      }
    }
  }
  renderer.setRendererHints(rendererParams);
  int maxErrors=wms.getMaxRenderingErrors();
  MaxErrorEnforcer errorChecker=new MaxErrorEnforcer(renderer,maxErrors);
  final RenderExceptionStrategy nonIgnorableExceptionListener;
  nonIgnorableExceptionListener=new RenderExceptionStrategy(renderer);
  renderer.addRenderListener(nonIgnorableExceptionListener);
  int maxRenderingTime=wms.getMaxRenderingTime() * 1000;
  RenderingTimeoutEnforcer timeout=new RenderingTimeoutEnforcer(maxRenderingTime,renderer,graphic);
  timeout.start();
  try {
    renderer.paint(graphic,paintArea,mapContent.getRenderingArea(),mapContent.getRenderingTransform());
    if (layout != null) {
      try {
        layout.paint(graphic,paintArea,mapContent);
      }
 catch (      Exception e) {
        throw new ServiceException("Problem occurred while trying to watermark data",e);
      }
    }
  }
  finally {
    timeout.stop();
    graphic.dispose();
  }
  if (timeout.isTimedOut()) {
    throw new ServiceException("This requested used more time than allowed and has been forcefully stopped. " + "Max rendering time is " + (maxRenderingTime / 1000.0) + "s");
  }
  if (nonIgnorableExceptionListener.exceptionOccurred()) {
    Exception renderError=nonIgnorableExceptionListener.getException();
    throw new ServiceException("Rendering process failed",renderError,"internalError");
  }
  if (errorChecker.exceedsMaxErrors()) {
    throw new ServiceException("More than " + maxErrors + " rendering errors occurred, bailing out.",errorChecker.getLastException(),"internalError");
  }
  if (palette != null && palette.getMapSize() < 256)   image=optimizeSampleModel(preparedImage);
 else   image=preparedImage;
  RenderedImageMap map=buildMap(mapContent,image);
  return map;
}
