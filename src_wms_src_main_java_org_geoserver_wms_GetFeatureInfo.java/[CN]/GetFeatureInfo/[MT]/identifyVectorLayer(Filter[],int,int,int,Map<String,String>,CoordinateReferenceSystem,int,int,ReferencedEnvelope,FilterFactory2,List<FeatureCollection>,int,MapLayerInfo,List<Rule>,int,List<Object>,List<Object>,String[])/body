{
  CoordinateReferenceSystem dataCRS=layer.getCoordinateReferenceSystem();
  double radius;
  if (buffer <= 0) {
    Integer layerBuffer=null;
    final LayerInfo layerInfo=layer.getLayerInfo();
    if (layerInfo != null) {
      layerBuffer=layerInfo.getMetadata().get(LayerInfo.BUFFER,Integer.class);
    }
    if (layerBuffer != null && layerBuffer > 0) {
      radius=layerBuffer / 2.0;
    }
 else {
      MetaBufferEstimator estimator=new MetaBufferEstimator();
      for (      Rule rule : rules) {
        rule.accept(estimator);
      }
      int estimatedRadius=estimator.getBuffer() / 2;
      if (estimatedRadius < MIN_BUFFER_SIZE || !estimator.isEstimateAccurate()) {
        radius=MIN_BUFFER_SIZE;
      }
 else {
        radius=estimatedRadius;
      }
    }
  }
 else {
    radius=buffer;
  }
  int maxRadius=wms.getMaxBuffer();
  if (maxRadius > 0 && radius > maxRadius)   radius=maxRadius;
  ReferencedEnvelope queryEnvelope=getEnvelopeFilter(x,y,width,height,bbox,radius);
  if ((requestedCRS != null) && !CRS.equalsIgnoreMetadata(dataCRS,requestedCRS)) {
    if (dataCRS.getCoordinateSystem().getDimension() == 3 && requestedCRS.getCoordinateSystem().getDimension() == 2) {
      queryEnvelope=JTS.transformTo3D(queryEnvelope,dataCRS,true,10);
    }
 else {
      queryEnvelope.transform(dataCRS,true);
    }
  }
  final FeatureSource<? extends FeatureType,? extends Feature> featureSource;
  featureSource=layer.getFeatureSource(false);
  FeatureType schema=featureSource.getSchema();
  Filter getFInfoFilter=null;
  try {
    GeometryDescriptor geometryDescriptor=schema.getGeometryDescriptor();
    String localName=geometryDescriptor.getLocalName();
    Polygon queryPolygon=JTS.toGeometry(queryEnvelope);
    getFInfoFilter=ff.intersects(ff.property(localName),ff.literal(queryPolygon));
  }
 catch (  IllegalFilterException e) {
    e.printStackTrace();
    throw new ServiceException("Internal error : " + e.getMessage(),e);
  }
  if (filters[i] != null) {
    getFInfoFilter=ff.and(getFInfoFilter,filters[i]);
  }
  Filter postFilter=Filter.INCLUDE;
  Filter rulesFilters=buildRulesFilter(ff,rules);
  if (!(featureSource.getSchema() instanceof SimpleFeatureType) || !(rulesFilters instanceof Or) || (rulesFilters instanceof Or && ((Or)rulesFilters).getChildren().size() <= 20)) {
    getFInfoFilter=ff.and(getFInfoFilter,rulesFilters);
  }
 else {
    postFilter=rulesFilters;
  }
  Filter timeElevationFilter=wms.getTimeElevationToFilter(times,elevations,layer.getFeature());
  getFInfoFilter=Filters.and(ff,getFInfoFilter,timeElevationFilter);
  SimplifyingFilterVisitor simplifier=new SimplifyingFilterVisitor();
  getFInfoFilter=(Filter)getFInfoFilter.accept(simplifier,null);
  String typeName=schema.getName().getLocalPart();
  Query q=new Query(typeName,null,getFInfoFilter,maxFeatures,propertyNames,null);
  if (viewParams != null && viewParams.size() > 0) {
    q.setHints(new Hints(Hints.VIRTUAL_TABLE_PARAMETERS,viewParams));
  }
  FeatureCollection<? extends FeatureType,? extends Feature> match;
  match=featureSource.getFeatures(q);
  if (!Filter.INCLUDE.equals(postFilter)) {
    match=new FilteringFeatureCollection(match,postFilter);
  }
  return match;
}
