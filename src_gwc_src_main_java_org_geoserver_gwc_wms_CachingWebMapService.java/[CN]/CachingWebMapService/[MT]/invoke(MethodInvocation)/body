{
  GWCConfig config=gwc.getConfig();
  if (!(config.isWMSCEnabled() && config.isDirectWMSIntegrationEnabled())) {
    return (WebMap)invocation.proceed();
  }
  final GetMapRequest request=getRequest(invocation);
  boolean tiled=request.isTiled();
  if (!tiled) {
    return (WebMap)invocation.proceed();
  }
  final StringBuilder requestMistmatchTarget=new StringBuilder();
  ConveyorTile cachedTile=gwc.dispatch(request,requestMistmatchTarget);
  if (cachedTile == null) {
    WebMap dynamicResult=(WebMap)invocation.proceed();
    dynamicResult.setResponseHeader("geowebcache-cache-result",MISS.toString());
    dynamicResult.setResponseHeader("geowebcache-miss-reason",requestMistmatchTarget.toString());
    return dynamicResult;
  }
  checkState(cachedTile.getTileLayer() != null);
  final TileLayer layer=cachedTile.getTileLayer();
  if (LOGGER.isLoggable(Level.FINEST)) {
    LOGGER.finest("GetMap request intercepted, serving cached content: " + request);
  }
  final byte[] tileBytes;
{
    final Resource mapContents=cachedTile.getBlob();
    if (mapContents instanceof ByteArrayResource) {
      tileBytes=((ByteArrayResource)mapContents).getContents();
    }
 else {
      ByteArrayOutputStream out=new ByteArrayOutputStream();
      mapContents.transferTo(Channels.newChannel(out));
      tileBytes=out.toByteArray();
    }
  }
  final String ifNoneMatch=request.getHttpRequestHeader("If-None-Match");
  final byte[] hash=MessageDigest.getInstance("MD5").digest(tileBytes);
  final String etag=toHexString(hash);
  if (etag.equals(ifNoneMatch)) {
    LOGGER.finer("ETag matches, returning 304");
    throw new HttpErrorCodeException(HttpServletResponse.SC_NOT_MODIFIED);
  }
  LOGGER.finer("No matching ETag, returning cached tile");
  final String mimeType=cachedTile.getMimeType().getMimeType();
  RawMap map=new RawMap(null,tileBytes,mimeType);
  map.setResponseHeader("Cache-Control","no-cache");
  map.setResponseHeader("ETag",etag);
  map.setContentDispositionHeader(null,"." + cachedTile.getMimeType().getFileExtension());
  final long tileTimeStamp=cachedTile.getTSCreated();
  final String ifModSinceHeader=request.getHttpRequestHeader("If-Modified-Since");
  final String lastModified=org.apache.commons.httpclient.util.DateUtil.formatDate(new Date(tileTimeStamp));
  map.setResponseHeader("Last-Modified",lastModified);
  final Date ifModifiedSince;
  if (ifModSinceHeader != null && ifModSinceHeader.length() > 0) {
    try {
      ifModifiedSince=DateUtil.parseDate(ifModSinceHeader);
      long ifModSinceSeconds=1000 * (ifModifiedSince.getTime() / 1000);
      long tileTimeStampSeconds=1000 * (tileTimeStamp / 1000);
      if (ifModSinceSeconds >= tileTimeStampSeconds) {
        throw new HttpErrorCodeException(HttpServletResponse.SC_NOT_MODIFIED);
      }
    }
 catch (    DateParseException e) {
      if (LOGGER.isLoggable(Level.FINER)) {
        LOGGER.finer("Can't parse client's If-Modified-Since header: '" + ifModSinceHeader + "'");
      }
    }
  }
  long[] tileIndex=cachedTile.getTileIndex();
  CacheResult cacheResult=cachedTile.getCacheResult();
  GridSubset gridSubset=layer.getGridSubset(cachedTile.getGridSetId());
  BoundingBox tileBounds=gridSubset.boundsFromIndex(tileIndex);
  String cacheResultHeader=cacheResult == null ? "UNKNOWN" : cacheResult.toString();
  map.setResponseHeader("geowebcache-cache-result",cacheResultHeader);
  map.setResponseHeader("geowebcache-tile-index",Arrays.toString(tileIndex));
  map.setResponseHeader("geowebcache-tile-bounds",tileBounds.toString());
  map.setResponseHeader("geowebcache-gridset",gridSubset.getName());
  map.setResponseHeader("geowebcache-crs",gridSubset.getSRS().toString());
  return map;
}
